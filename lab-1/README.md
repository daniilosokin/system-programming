# Системное программирование. Лабораторная работа №1: Файлы и каталоги

**Цель работы:** обучение взаимодействию с файловой системойчерез
команды оболочки и системные вызовы ОС.

## Теоретическая часть

В UNIX-подобных системах понятие файла является центральным, поскольку
в виде объектов файловой системы представляются не только обычные данные, но
и многие объекты ОС: процессы и потоки, оперативная память, устройства,
примитивы синхронизации и т.д («**В UNIX все есть файл**»).

### Определения

**Файл** — именованный набор данных.

**Файловая система** (ФС) — система, обеспечивающая взаимодействиес
файлами. В частности, ФС определяет порядок сопоставления имени и набора
данных.

**Индексный узел** (i-node) — структура, хранящая метаданные файла (тип,
атрибуты, расположение блоков данных на диске и т.д.). Индексный узел не хранит
имя файла.

**Каталог** — файл специального вида, хранящий информациюо связанных с
ним (вложенных) файлах. Любой каталог как минимум содержит подкаталоги
`.`(ссылка на самого себя) и `..` (ссылка на родительский каталог).

**Корневой каталог** – каталог, являющийся корнем дерева файловой системы
UNIX. Имя корневого каталога – `/`.

**Абсолютный путь** – путь, начинающийся с корневого каталога (первый
символ равен `/`).

**Рабочий каталог процесса** – каталог, от которого отсчитываются
относительные пути.

**Относительный путь** – путь, не начинающийся с корневогокаталога (первый
символ не равен `/`). Эквивалентный абсолютный путь равен <рабочий
каталог>/<относительный путь>.

**Жесткая ссылка** — запись в каталоге. Жесткая ссылкасопоставляет имя
файла в каталоге и его индексный узел. Несколько записей из разных каталогов
могут указывать на один и тот же узел. Индексный узел не удаляется, пока есть хотя
бы одна ассоциированная с ним жесткая ссылка.

**Символьная ссылка** — специальный файл, хранящий имя (путь)
файла-назначения и позволяющий взаимодействовать с ним. При удалении
файла-назначения жесткая ссылка становится висячей (dangling).

**Файлы устройств** — файлы, представляющие (псевдо)устройства в
файловой системе. Обычно располагаются в каталоге `/dev`.

**Символьное устройство** – устройство, ориентированноена
последовательное чтение/запись без возможности произвольного доступа.
Примером файла символьного устройства является терминал (файл `/dev/tty`).

**Блочное устройство** — устройство, ориентированное напроизвольный
доступ к данным. Примером блочного устройства является жесткий диск 
(файл `/dev/sda`).

**Дескриптор файла** – целое неотрицательное число, являющеесяиндексом в
таблице открытых файлов процесса.

### Полезные системные вызовы

#### Манипуляции с рабочим каталогом

```c++
char* getcwd(char* buf, size_t size); // получить рабочий каталог
```

Вызов `getcwd` принимает на вход буфер и размер буфера, в который
записывается строка, содержащая абсолютный путь к рабочему каталогу (включая
оконечный нулевой символ). В случае успеха возвращается buf. Если размер
буфера недостаточен, возвращается `NULL`, и `errno` выставляется в `ERANGE`.

В POSIX явно не указывается, что произойдет, если `buf == NULL`. Разные ОС
определяют собственное поведение (см. `man getcwd`).

```c++
int chdir(const char* path); // изменить рабочий каталог
```

Вызов `chdir` возвращает `0` в случае успеха и `-1` в случае ошибки. В случае
ошибки причина ошибки указана в `errno` (см. `man chdir`).


#### Создание, открытие и закрытие файлов

```c++
/* открыть файл */
int fd = open(const char *pathname, int flags, mode_t mode);
```

Данный системный вызов открывает файл с именем `pathname` и возвращает
дескриптор файла. Дополнительные опции передаются через `flags` (отдельные
опции объединяются посредством побитового ИЛИ). Среди полезных опций:

`O_CREAT` – создать файл, если не существует.

`O_TRUNC` – если файл существует и открывается для записи, стереть старые
данные.

`O_APPEND` – всегда записывать данные в конец файла.

`O_EXCL` – используется совместно с `O_CREAT`. В случае, если файл существует - 
завершить вызов с ошибкой. Иными словами, комбинация `O_CREAT|O_EXCL`
позволяет убедиться, что был создан новый файл, а не открыт уже существующий.

`O_DIRECTORY` – вернуть ошибку, если открываемый файл не является
каталогом. Обычно используется, если полученный дескриптор планируется
передать последующему вызову `opendir` или `fopenat/fchdir/fpathconf` (см. `man`
для указанный функций).

Параметр `mode` содержит флаги доступа, которые устанавливаются при
создании нового файла (параметр игнорируется приоткрытии уже существующего
файла). Для выполнения лабораторной достаточно указать в качестве значения
параметра константу `S_IRWXU` (права на полный доступ к файлу для создателя
файла).

```c++
/* закрыть открытый файл*/
int close(int fd);
```

Хотя желательно закрывать файлы сразу после того,как они станут ненужны,
строго говоря, это не обязательно. Все открытые файлы автоматически закроются
при завершении процесса.

#### Чтение и запись

```
/* прочитать данные из файла */
ssize_t read(int fd, void* buf, size_t count);

/* записать данные в файл */
ssize_t write(int fd, const void* buf, size_t count);
```

Первым параметром `fd` обоих вызовов является дескриптор открытого файла.
Параметр `buf` должен содержать указатель на буфер данных.В параметре `count`
передается число байт, которые надо прочитать из буфера/записать в буфер.
Очевидно, что размер буфера должен быть больше `count`.

Возвращаемым значением обоих вызовов является число фактически
считанных/записанныхбайт. Это значение может быть меньше `count`. Например, в
случае чтения данное значение будет меньше, если достигнут конец файла (`0` – если
конец файла уже был достигнут и новых данных больше нет). В случае записи
данное значение будет меньше, если диск заполнен и удалось записать только часть
данных. В случае, если ошибка произошла дотого, как какие-либо данныебыли
прочитаны/записаны, возвращенное значение будет равно `-1` с кодом ошибки в
`errno`.

```c++
/* изменить позицию чтения записи */
off_t lseek(int fd, off_t offset, int whence);
```

Вызов изменяет текущую позицию в файле. Следующая операция
чтения/записи будет начинаться по новой позиции.

Тип `off_t` соответствует одному из знаковых целочисленных типов. Аргумент
`fd` соответствует дескриптору файла. Аргумент `offset` содержит значение, на
котороеизменяетсяпозициявфайле.Воwhenceпередаетсяоднаизименованных
констант `SEEK_SET`, `SEEK_CUR`, `SEEK_END`. Если `pos` – позиция в файле, `file_size` –
размер файла, то, в зависимости от значения `whence`, новая позиция вычисляется
следующим образом:

```c++
if (whence == SEEK_SET)
  pos = offset; /*новое значение равно заданному*/
else if(whence == SEEK_CUR)
  pos += offset; /*позиция смещается на offset байт от текущей*/
else if(whence == SEEK_END)
  pos = file_size + offset; /*позиция смещается на offset байт от конца файла*/
```

В случае успеха возвращается новое значение позиции. В случае ошибки
возвращается `-1` с кодом ошибки в `errno`. Ошибка возможна, например, при работе с
файлом символьного устройства, которые не поддерживают чтение/запись по
произвольной позиции.

#### Изменение размера файла

```c++
/* изменить размер файла */
int ftruncate(int fd, off_t length); 
```
В аргументе `fd` должен передаваться дескриптор файла, открытого на запись.
В случае, если значение `length` меньше текущего размера данных, данные в конце
файла теряются. В случае, если значение `length` больше, чем текущий размер
файла, его размер увеличивается до `length` (с дополнением нулями).

В случае успеха возвращается `0`. В случае ошибки возвращается `-1` с кодом
ошибки в `errno`.

#### Создание ссылок

```c++
/* создать жесткую ссылку */
int link(const char *oldpath, const char *newpath);
```
Путь `oldpath`, должен указывать на существующий файл. Все каталоги в пути
`newpath` должны существовать, но сам целевой файл существоватьне должен.

Вызов возвращает `0` в случае успеха и `-1` в случае `ошибки`.

*Жесткие ссылки на каталоги может создавать только суперпользователь,
однако создание таких ссылок может приводить к зацикливанию и повреждению ФС*.

```c++
/* создать символьную ссылку */
int symlink(const char *target, const char *linkpath);
```
Вызов создает символьную ссылку на `target` по пути `linkpath`, при этом `target`
может указывать на несуществующий файл. Вызов возвращает `0` в случае успеха и `-1` в
случае ошибки.

Поскольку символьная ссылка является отдельным файлом, она может также
быть открыта вызовом `open()`, для этогов `flags` нужнопередать `O_NOFOLLOW`. По
умолчанию `open()` открывает именно файл, на который указывает символьная
ссылка.

Символьные ссылки на каталоги создавать можно.

#### Удаление файлов

```c++
/* уничтожить жесткую ссылку */
int unlink(const char* path); 
```
Параметр `path` должен содержать путь к файлу (но не к каталогу).

Вызов возвращает `0` в случае успеха и `-1` в случае ошибки.

Вызов `unlink` уничтожает жесткую ссылку на файл, т.е. удаляет
соответствующую запись из каталога. Если path указывает на символьную ссылку,
будет уничтожен файл символьной ссылки. Окончательно *файл удаляется с диска
только если на него не осталось жестких ссылок*.

Следует отметить, что *файл не будет окончательно удален с диска до тех пор,
пока он открыт хотя бы одним процессом*. Если на файл больше нет жестких ссылок,
но он открыт в программе, он будет удален после завершения программы.


#### Создание и удаление каталогов

```c++
/* создать каталог */
int mkdir(const char* path, mode_t mode);
```
Параметр `path` содержит путь, по которому создается директория. Параметр
`mode` должен содержать права доступа к создаваемой директории, однако в пределах
лабораторной его можно считать равным `S_IRWXU`. Вызов возвращает `0` в случае
успеха и `-1` в случае ошибки.

```c++
/* удалить каталог */
int rmdir(const char* path);
```
Параметр `path` содержит путь к удаляемой пустой директории. Вызов
возвращает `0` в случае успеха и `-1` в случае ошибки.

#### Просмотр каталогов

```c++
/* получить список всех элементов каталога */
int scandir(const char *dirp,
            dirent ***namelist,
            int (*filter)(const dirent *),
            int (*compar)(const dirent **, const dirent **)
);

/* функция, сравнивающая элементы каталога по имени */
int alphasort(const dirent **a, const dirent **b);
```
Формально `scandir` не является системным вызовом. Данная функция
открывает файл каталога на диске, читает его и возвращает все его элементы. Путь к
каталогу передается в `dirp`.

В случае успеха возвращается число элементов каталога. В случае ошибки
возвращается `-1`. Массив элементов каталога возвращается через `namelist`. Память
для массива и для структур `dirent` выделяется с помощью `malloc`. Освободить
память должен сам разработчик.

Структура `dirent` определена POSIX, как
```c++
struct dirent {
ino_t d_ino;
char d_name[NAME_MAX+1]; // имя файла
/*...*/
};
```

В структуре может быть больше полей — в зависимости от ОС.

В параметре `filter` может передаваться функция-фильтр, котора отбирает
только элементы каталога, подходящие под определенные условия. Если в `filter`
передан `NULL`, то возвращаются все элементы каталога.

Параметр `compar` должен содержать функцию-компаратор, которая
используется при сортировке элементов каталога. Для сортировки элементов
каталога по имени можно передать в `compar` функцию `alphasort`.

Пример использование `scandir` можно найти в документации (см. `man scandir`):
```c++
int main(void)
{
  struct dirent **namelist;
  int n;
  
  n = scandir(".", &namelist, NULL, alphasort);
  if (n == -1)
  {
    exit(-1);
  }
  
  while (n--)
  {
    printf("%s\n", namelist[n]->d_name);
    free(namelist[n]);
  }
  
  free(namelist);
  exit(0);
}
```

### Полезные команды оболочки

#### Манипуляции с рабочим каталогом

```bash
pwd       # распечатать рабочий каталог
cd <путь> # изменить рабочий каталог
```

####  Создание файлов

В оболочке создание файла может быть произведено двумя способами.

Первый способ — это перенаправление потока вывода какой-либо программы.
Например, текстовый файл `foo` с текстом `«bar»` может быть создан командой

```bash
$ echo bar > foo
```
Второй способ — команда `touch`. Данная команда обновляет имя доступа к
файлу, если он существует, иначе — создает пустой файл. К примеру, данная
команда создаст пустой файл `foo`.

```bash
$ touch foo
```

#### Изменение размера файла

```bash
truncate -s <число> <файл> # изменить размер файла на указанный
```

Если файл не существует, он будет создан и при необходимости заполнен `0`.

#### Чтение и запись файлов

Прочитать весь файл можно утилитой `cat`. Если файл не указан, `cat` будет
дублировать в поток вывода все данные из потока ввода.


```bash
cat <файл> # вывести в поток вывода все содержимое файла
```
Если необходимо вывести в поток вывода только часть файла, можно
воспользоваться комбинацией команд `head` и `tail`.

```bash
head [-c/-n <число>] <файл> # прочесть данные в начале файла
tail [-c/-n <число>] <файл> # прочесть данные в конце файла
```
Ключ `-с` интерпретирует число как число байт, которые нужно прочесть. Ключ
`-n` интерпретирует число как число линий. При отсутствии каких-либо опций
подразумевается `-n 10`.

В комбинации с конвейерами данные команды позволяютчитать файлы по
частям. Например, данная команда выведет только линии с 100 по 120.

```bash
$ cat foo.txt | head -n 120 | tail -n 20
```
Запись в начало/середину файла из консоли возможна, но нетривиальна.
Дополнить файл легко с использованием перенаправления `>>` вместо `>`.

```bash
$ echo bar > foo # перезаписать foo
$ echo bar >> foo # дополнить foo
```

#### Создание ссылок


В оболочке оба типа ссылок могут быть созданы командой `ln`.

```bash
ln [-s] <имя файла> <имя ссылки> # создать ссылку на файл
```
По умолчанию данная команда создает жесткую ссылку. Для создания
символьной ссылки нужно указать флаг `-s`.

```bash
$ ln file.txt hrdlnk.txt # создать жесткую ссылку hrdlnk.txt
$ ln -s file.txt symlnk.txt # создать символьную ссылку symlnk.txt
```
Допустимо создавать символьные ссылки на каталоги. Жесткие ссылки на
каталоги может создавать только суперпользователь, однако создание таких ссылок
может приводить к зацикливанию и повреждению ФС.


#### Создание каталогов

Каталоги могут быть созданы командой `mkdir`:

```bash
mkdir [-p] <путь> # создать каталог
```

Ключ `-p` создает все каталоги в указанном пути, если они не существуют.

#### Просмотр каталогов

Просмотр элементов каталога осуществляется командой `ls`.

```bash
ls [-R -a -l -h] <путь> # вывести элементы каталога
```
Ключ `-R` позволяет вывести содержимое каталога и всехподкаталогов.

Ключ `-a` позволяет вывести все скрытые файлы.

Ключ `-l` позволяет вывести свойства файлов.

Ключ `-h` выводитразмер файлов в человекочитаемом формате (`1M` вместо `1048576`).


#### Удаление файлов и каталогов

Файлы и каталоги могут быть удалены командой `rm`
```bash
rm [-R -d] <путь> # удалить файл или каталог
```

По умолчанию `rm` может удалить только файл. Ключ `-d` позволяет удалить
пустой каталог. Ключ `-R` позволяет удалить непустой каталог.

#### Полезные файлы

`/dev/zero` – бесконечный файл, чтение из которого возвращает 0, а запись
приводит к потере записанных данных.
`/dev/urandom` – бесконечный файл, чтение из которого возвращает
псевдослучайные данные.
`/dev/random` – бесконечный файл, чтение из которого возвращает случайные
данные.


#### Скрипты

Помимо выполнения команд, оболочка может выполнять программы,
написанные на скриптовом языке оболочки (скрипты). Каждаяоболочка обладает
собственнымязыком длянаписания скриптов. Впростейшемслучаескрипт—это
последовательность команд оболочки.

По умолчанию файл скрипта не является исполняемым. Чтобы выполнить
скрипт, необходимо явно разрешить выполнение командой:
```bash
$ chmod u+x script.sh
```

После получения права на исполнение скрипт может быть запущен на выполнение
так же, как и любая программа:
```bash
$ ./script.sh
```

## Задание на лабораторную работу

Преподавателем задается структура некоторого каталога с его содержимым.
Для файлов задаются имя, размер и контент (пустой файл, заданная строка,
случайные данные).
Каталог задается во время занятия, каждая попытка сдачи лабораторной — 
новый каталог со своей структурой.

Необходимо:
- Написать программу на языке С/С++, создающую заданный каталог со всем
содержимым. Для манипуляции с файлами/каталогами запрещено использовать
что-то,кроме приведенных здесь функций. Результат подтвердить выводом команды
`ls` (или `tree`).
- Написать sh-скрипт, создающий тот же самый каталог в оболочке
(допустимо создать каталог командами оболочки в реальном времени под
наблюдением преподавателя). Результат подтвердить выводом команды `ls` (или `tree`).

Рекомендуется заранее написать заготовку для программы на C/C++.

Варианты лабораторной:
- **_Легкий_:** все файлы являются обычными, контент файлов — заранее
определенные строки.
- **_Средний_:** легкий+ вместофайлов могут использоваться ссылки+контент
файлов может быть случайным.
- **_Сложный_:** средний + написать программу на С/С++, удаляющуюваш каталог.

Пример задания:

```
a/b/cat.txt (“catts”)
/c/dog.txt (пустой)
/d (ссылка на /c)
/e/f.txt (жесткая ссылка на b/cat.txt)
/g.bin ( 500 байт, случайный)
/h.bin ( 35 байт, заполнен 0 )
```

Пример соответствующего sh-скрипта:

```bash
mkdir a
cd a
mkdir b c e
ln -s c d
cd b
echo catts > cat.txt
cd ../c
touch dog.txt
cd ../e
ln ../b/cat.txt f.txt
head -c 500 /dev/urandom > g.bin
_truncate -s 35 h.bin
cd ../.._
```

---

**Работа выполнена на сложный уровень.**
